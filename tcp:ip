OSI 7层通信
应用层
表示层
会话层         Http，ssh
传输层         TCP,UDP          端口号
网络层         IP               IP地址
数据链路层      以太网            Mac地址
物理层



- IP：无连接的点对点通信

  三个模块： 寻址, 路由, 分包组包

  ​		寻址：ip地址

  ​		路由：路由选择和路由表

  ​		分包组包： MTU(链路的最大传输单元)

  ​				路径MTU发现，UDP会直接尝试，TCP一般就不会让IP层再去分片了

- 路由协议：目的是为了进行正确的转发，可能会基于UDP,TCP或者IP协议上运行
      包含： IGP(内部网关协议)和EGP(外部网关协议)
          IGP:主要包含 RIP和OSPF
              RIP:根据向量距离选择(跳数)，转发自己的信息给邻居，主要是循环无法解决
              OSPF:维护一个完整的拓扑信息
          EGP:
              BGP:包含完整路径的一个访问列表去选择

- IP的辅助技术:
      DNS:主机名和IP地址的映射
      ARP:根据IP地址确定Mac地址(不涉及路由选择)
          包含： ARP请求包，ARP响应包
          EXTEND: RARP(一台服务器，反过来根据mac确定ip,用于非DHCP的设置自己的ip)
      ICMP: 网络问题诊断的协议, **基于IP的**(但是不属于传输层)
            主要是通过发送包之后返回状态或者错误消息
      DHCP: 一台服务器，实现自动设置IP地址，统一管理IP地址分配
          4步：DHCP发现包，提供包，请求包，提供包
      NAT: 解决IP地址不够用或者区分私有和全局IP地址

- 端口：传输层的地址，但是判断一个通信消息是根据(源、目的IP地址，源、目的端口号， 协议号)来唯一确定的，注意这里有协议号的存在，所以TCP的端口80和udp的端口80是不同的通信


- TCP: 面向连接，可靠的传输协议
  - 连接，确认应答，重发，窗口，拥塞控制
    - 连接： 三次握手，四次挥手
    - 确认应答:ack,发送消息后要返回一个确认收到的信号
    - 重发：发送之后收不到ack的消息，就再次重发，主要是重发时间和重发哪些数据的判断
    - 窗口：也是滑动窗口，其实就是一个并发策略，连续发送几个包，根据返回值确认重发哪些
    - 拥塞控制：慢启动(先指数，后单个增加),超时后的重复处理(超时重来，重复确认减半)
  - 怎么样建立连接和终止(详细理解: TCP/IP协议17-24章节)：
    - 三次握手： SYN-SYN/ACK-ACK
    - 四次挥手： FIN-ACK-FIN-ACK
    - 全双工的体现和字节序号
    - 连接过程和终止过程的注意点：
      - MSS(最大报文段)，表示一个报文段的最大值，这个值是有两边商量决定的，两边及链路的最小值确定
      - 半关闭：一遍发起了FIN,并且接受到了ACK,此时当前端无法发送数据，但还是可以接收数据和返回ACK
      - TCP的装态变迁图，主要关注点是TIME_WAIT状态下需要有个2MSL的等待时间，而且这个等待时间只是在最先发起关闭的一端
      - 为什么是2MSL？主要是保证前一个连接的数据在整个链路中消失
        - https://cloud.tencent.com/developer/article/1450264
      - RST(reset,重置字段)
        - 告知请求方这个连接已经不再可用了，请求方收到这个字段后也不再返回ACK了
      - TCP服务器：
        - 对本地IP地址做限定，远端IP地址一般不限定
      - TCP连接的队列，这个队列都是在建立好连接之后再给到客户端去做处理，如果当前队列占满了的话，也不作任何回应，让客户端自己做超时
  - 传输数据：
    - 控制(交互数据流)，都是特别小的数据块，甚至比TCP首部都还小的
      - 时延确认，即每一个tick-tock之后才发回ACK
      - Nagle算法：保证TCP的连接中只有一个未被确认的小分组
        - 目的是让客户端的发送也变成几个小分组合在一起发。
        - 但是并不是单纯的合并几个小分组，而是自适应整个连接的速度的，吞吐量越快，那么发送响应也越快，否则发送分组较大，延迟也较高
    - 成块数据流, 数据量比较大的，需要进行多次传输的
      - 滑动窗口：
        - 既然需要连续的多次传输，而ACK是一个累加的确认，那么可以用窗口来发送
        - 这是服务端通过返回值来控制窗口大小的
      - PUSH字段：
        - 催促服务端赶紧将自己的缓存给到应用端去，从而释放空间继续传输
          - URG urgency，紧急数据
          - 可以跟着普通数据一起传输，需要设置字段以及结束位置
  - 超时与重传
    - 拥塞窗口: cwnd 控制发动端的发包速率 
    - 慢启动：每收到一个ACK,就增加一个可以发的空间
    - 指数退避：
      - 这个是指重传超时时间RTO随着重传次数做指数及增长
        - RTT的计算，RTO的值则是依赖于RTT的计算的
    - 拥塞避免算法：
      1. 首先慢启动，保证传输窗口 < min(拥塞窗口，滑动窗口(通告大小))，超过ssthresh后cwnd一个一个增加
      2. 发现有超时或者连续重复ACK之后，ssthresh = 当前传输窗口 / 2,
      3. 拥塞窗口：超时 cwnd为1, 重复三次ACK, cwnd=ssthresh
         1. 快速重传：知道超时或者3个重复ACK(通告窗口大小不变)，则立即重传重复ACK所需的报文段
         2. 快速恢复：
            - 3个重复ACK时，使用的是cwnd = ssthresh, 而不是 == 1
            - 重传可以重新分组，而不一定保持原来的分组
            - ICMP的不可达对于TCP是可识别的，并不会直接断掉连接，而是先按超时重传算，但是最终返回信息不是“连接超时”
  - 两个定时器：
    - 坚持定时器：
      - 查询通告窗口是否扩大了，时间也采用指数退避，但是到达最大值后不会断开，按照最大值继续发
      - 糊涂窗口综合征：小窗口不要快读通知发送端，否则全是些小数据块，增加网络负担
        - 发送端，接收端都增加一个控制判断
    -  保活定时器：
      - 一般用于判断对方是正常连接着还是已经崩溃了
      - 如果崩溃了，那么再发送75s/次，10次请求，就收到连接超时
      - 如果崩溃的重启， 返回RST，reset
      - 如果不可达，就是ICMP的不可达处理，见上面ICMP的消息处理机制
  - UDP：面向数据报的(不可靠的)传输层协议
    - 传输快，没有建立链接等等的过程，但是不可靠(指的是不一定能把数据送到，没有重发机制)
    - 数据报的大小没有限制，又IP层来对其进行分片
    - 检验和，这个是对包含对UDP首部合并UDP数据的所有数据的检验和，这样能在接收端判断接收到的数据是不是完全正确的





应用层协议：
    FTP: 基于TCP, 21号端口控制连接，20号端口数据传输，即包含两个TCP连接
    SSH: 基于TCP, 22号端口
    SMTP: 发送电子邮件协议 TCP,25号端口
    POP,IMAP:接受电子邮件的协议，一个可以有标记分类，一个不可以

