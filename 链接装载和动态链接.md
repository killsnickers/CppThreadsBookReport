# 链接

整体其实在编译为ojb对象之后到程序运行中间，这里有三个重要的过程

1. **静态链接**(链接器参与)，生成可执行文件
2. **装载**，将可执行文件加载到内存上，作为程序准备运行
3. **动态链接**(动态链接器参与(一个特殊的共享对象))，包括运行前加载的和运行时加载的共享对象

## 静态链接

问题：

1. 空间和地址的分配
2. 符号解析和重定位
3. 什么是静态库链接
4. 链接过程中的一些可自行控制的部分

解析：

- 空间，这里主要说的是可执行文件装载后的虚拟地址空间
- 链接：两步：空间地址分配，符号解析和重定位 
- 链接过程中是如何去确定这个别的源文件的符号的以及对应地址的？
  - 首先是对于只要是一个段内的符号(不包括在栈中定义的那些)，由于段内的相对位置已经确定，然后段的起始位置也确定了，那么就可以确定处该符号的虚拟地址。(但是对于一些引用其他目标文件的全局变量，只知道现在在程序中的虚拟地址，但是不知道真正的位置，就只能通过符号解析和重定位来确定了，这个计算过程正是链接的主要过程)
  - 既然要重定位，首先是得找到那些符号需要重定位，这个就是一个重定位表来包含该部分信息，同时重定位表是一个数据结构，包含重定位入口和重定位类型，符号所在符号表中的位置
- 区别静态链接和静态库链接，静态库指的是一组目标文件的集合，把需要的.o文件包装在一起就是一个静态库。而静态链接的是将多个.o文件进行合并，重定位等等生成一个可执行文件。 
- 关于链接过程中的可控制部分，其实本身可以自行写链接脚本来制定那些段合并，那些段不需要，程序的入口函数是什么等等。(此处涉及比较底层的东西，需要该部分知识的时候再去补充)
- BFD库，在gcc、gdb、ld、等中间的一个真正去底层操作未见的借口，这样就可以在BFD库新增其他类型文件，提供相应接口就可以，于gcc、ld等的操作隔离开，降低耦合

## 装载

问题：

1. 什么是装载
2. 什么是进程虚拟空间以及为什么要用虚拟空间的方式，以及整个进程的内存结构是怎么样的
3. 虚拟地址、内存、可执行文件 三者之间是如何交互
4. 真实场景实现 Linux和Windows

解析

- 装载，就是把可执行文件从外部存储器读到内存中的某个位置
- 每个程序运行起来的时候，都有自己独立的虚拟地址空间，大小有内存决定，同时还得减去系统占据的一部分内存空间
- 动态装入，程序运行时有局部性原理，所以可以只保留部分常用的数据在内存，其余的需要再加载
  - 覆盖装入，需要程序员手动管理，需要哪个装入哪个，覆盖不需要的
  - 页映射，所有的数据都是以页为单位划分，装载和操作的单位也是页，那么只需要给少部分页就可以运行整个程序
- 进程虚拟空间就是进程独立性的一种很好的体现。
- 虚拟地址，内存，可执行文件之间的交互(从一个进程的建立作为例子进行分析)
  - 创建独立的虚拟地址空间， 这里首先的概念是给每一个进程一个虚拟的地址空间，这样进程的寻址就是在自己的虚拟空间上进行的，跟其他的程序是没有任何关系的。然后就是做好虚拟空间的每一页到物理内存的页的映射
  - 读取可执行文件的头，建立一个虚拟空间到可执行文件的映射关系，就是如果内存中没有相关数据的时候，需要到可执行文件的那部分去读取相应的信息
  - 将CPU指令寄存器设置到可执行文件的入口，然后启动程序、
- 进程虚存空间分布
  - 首先这里需要区分section和segment，elf文件中，是以section为单位，在静态链接中，则会有section合并的现象产生，但是产生的依旧是section，而将elf文件装载的时候又再一次合并section(根据读写权限，减少内存碎片)形成segment。也就是第一个点，节合并为段进行加载
  - 堆和栈也是一个单独的segment， 但是没有对应的可执行文件相关内容
  - 段地址对齐。由于页映射的关系，导致所有的段都得以页为最小单位，那么就会有很对内存碎片，所以解决方案变成让段接壤部分共享一个物理页面，然后映射到虚拟内存空间两次或者多次。而虚拟内存空间的段地址对齐则是节约不节约也问题不是很大
  - 补充：段的建立，包含哪些section这个过程其实是在形成elf可执行文件的时候就已经确定了的。但是将段地址对齐，节省物理空间的过程却是在装载过程来执行的
- 真实加载过程
  - Linux：fork->execve->load(检查elf文件有效性->设置动态链接路径->建立VMA的映射->初始化环境->跳转到elf程序入口)
  - Windows：总体顺序差不多，主要是Windows的PE段起始地址就是页的倍数，所以不用合并

## 动态链接

问题：

1. 动态链接优缺点
2. 理论支撑
3. 相关数据结构和文件结构支撑
4. 真实场景实现

解析

- 优缺点：
  - 优点：
    - 避免多个程序重复装载某些基础的库，导致内存和硬盘空间的浪费
    - 动态的更新，不需要整个程序重新链接
  - 缺点：每次装载都需要重新链接，性能上会有损耗
- 链接过程中，动态链接库得作为输入文件之一
- 装载重定位能解决动态链接库中可修改数据部分，但是指令部分不行
- 理论支撑中的四种访问方式
  - 模块内部的指令访问， 相对地址即可
  - 模块内部的数据访问，相对地址访问即可
  - 模块外部的指令访问，GOT
  - 模块外部的数据访问，GOT
- 特殊情况 ：可执行文件内部的extern的变量无法确认是模块内部的还是跨模块的

