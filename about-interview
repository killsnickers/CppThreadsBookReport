常见面试问题的汇总
c++：

    new malloc什么区别
        new操作符，自由存储区上动态分配内存空间,返回的是对象类型的指针
            分配失败会抛出bad_alloc的异常，会构造对象，然后将指针给到返回值，字节的计算都是编译器来计算的
            允许函数的重载 其实是调用 new(size_t),如int *d= new int,其实是调用new(size_of(int))
        malloc 从堆上动态分配内存 返回的是void*
            失败会但会Null，所以会去检测，显示的指定字节数
            没有重载，没有构造，只是给定一个空间
        malloc的实现方案
            底层调用操作系统的接口，然后对于linux下面，则是在malloc的时候从当前的结果开始，往后搜寻，直到找到能够容纳整个变量的空间，否则就会去移动内存最后的指针，去申请新的空间
        new的底层实现
            new底层实际是去调用new()函数，该函数的简单数据模式就是去malloc就可以，如果是自定义的类型，那么还会去做的就是去调用构造函数，然后问题是它如果失败了，那么有出错处理，但是malloc就完全没有这方面的操作了
            EXTEND new, operator new, placement new
                new:操作符
                    如上所示，包括分配内存空间，调用构造函数，返回对象类型指针，这是一套完整的流程
                    其中分配内存空间，就是在operate new这里去做的
                operate new: 函数
                    这就是一个单纯分配空间的操作，但是它可以重载(一般是在类中重载)， 返回类型为void*
                placement new: 函数，看作是operate new的一个重载
                    主要是把一个已知空间拿来自己用，然后自己执行构造函数，并返回对应地址，但是并不会去申请空间，而是用已有的空间，所以不存在说分配失败的问题
                    1. 缓冲区提前分配，可以使用堆的空间，也可以使用栈的空间。所以分配方式有如下两种：
                        class MyClass {…};
                        char *buf = new char[N * sizeof(MyClass)];
                        char buf[N * sizeof(MyClass)]; (栈中分配内存？)
                    2. 对象的构造
                        MyClass * pClass = new(buf) MyClass; //使用placement new
                    3. 对象的销毁
                    一旦这个对象使用完毕，你必须显式的调用类的析构函数进行销毁对象。但此时内存空间不会被释放，以便其他的对象的构造。
                        pClass->~MyClass();
                    4. 内存的释放
                    如果缓冲区在堆中，那么调用delete[] buf 进行内存的释放。如果在栈中，那么在其作用域内有效，跳出作用域，内存自动释放。

    static 关键字
        必然引出的问题是静态持续变量, 分三种
            外部的静态持续变量    程序的其他文件中使用，其他文件使用的时候要用extern
            内部的静态持续变量    包含该文件的文件中使用
            没有连接性的持续变量     函数中使用
    const
        修饰的变量和类都是不能被更新的
        类中的const变量必须通过初始化列表进行初始化
        对于const 修饰变量导致的变量的作用域变化的问题，首先在头文件中定义，然后可以直接在调用该头文件的地方直接使用它
            如果是在其他文件中，而当前文件并没有去引用该文件，则无法使用，那么可以再该文件的中用extern,然后在当前文件中也用extern来调用
        const 主要结合指针的操作：
            const int* ptr，指定ptr所指的内容是const，不能通过ptr去修改ptr所指向的内容，但是可以让ptr去指向
                另一个常量
            int* const ptr, ptr是个常量，并且需要初始化，然后ptr指向的地址相当于不变了，但是里面的内容如果别的
                指针也访问这个地址并修改了的话则是允许的
        区别 static:
            static 一般在定义初始化之后是不会删除的，而const则是一个局部变量而已，如果在类内，会随着类的析构
                而删除

    C++ 一个源文件从文本到可执行文件的经历过程
        预处理，编译，汇编，链接
        预处理：生成.i文件,删除#define, 处理条件预编译指令，#include指令，去除注释等等
        编译，汇编：.s文件，主要是词法、语法、语义的分析，中间语言生成，目标汇编代码的生成
        链接: .o文件，这个时候的输出就是目标文件
            链接也分为静态链接和动态链接，这两种链接都是在基于.o的基础上去做的
            根据链接的文件，可以生成静态库.a,和动态库.so。
            动态链接和静态链接的区别：
                静态链接可以认为是将静态的.o文件和当前的代码进行联合起来编译
                动态链接则是在运行的时候才再去寻找和链接，那么导致在运行的时候要保证可以搜寻到，同时这样也会有带来单独更新某一个动态库而不用在重新编译当前的代码
        对于每个目标文件的组成，
            自己的数据和二进制代码
            未解决的符号表：引用了，但是定义不在本编译单元的符号
            导出符号表：本编译单元有，并且愿意分享给其他单元
            地址重定向表：提供本编译单元对自身地址的引用和记录

    extern关键字
        1、变量和函数定义在其他的模块中，需要去其他的模块中找
        2、extern "C" 保持这个函数名称，用C语言的函数名称寻找方式去寻找函数，而不是C++的被爆改的方式

    右值引用、移动语义
        左值(可以取地址)，右值(没法获取地址)，左值引用(T&)，右值引用(T&&)，移动赋值，完美转发(forward实现)
        解决的问题：
            目前问题是对于临时变量，进行赋值之后就不再用了的类型，每次都要去拷贝一次，消耗很大，尤其是如果该类型里面有数组啊等复杂类型的时候，所以如果直接把他的所有内容都拷贝到新的这个里面就可以
        std::move()用来移动左值，应该是直接调用右值的函数，问题是c++里面能区分左右值吗？怎么区分的 
        std::forward<>(),这个就是看你的T是什么了，如果T是int&的话就还是一个左值了
    智能指针：
        是什么？有哪些？为什么引入？
        自动分配、回收动态内存的指针
        shared_ptr(多个共享，引用计数), weak_ptr(依附sp,单独计数）, unique_ptr(唯一，无法赋值，可以move)
        为了防止传统指针的new后不再去回收，造成内存泄露
        可能出现的问题： 智能指针可能会出现循环引用的问题
    多态：
        是什么？为什么？怎么实现的？
        继承同一个基类，产生派生类，每个派生类的实现又各不相同
        这样可以提取出公共的部分，实现一个方法，多处使用，每处还会有不同实现
        通过虚函数的方式
            虚函数： 是什么？为什么？怎么实现？
            基类指针指向子类是,确保调用的是子类的实现而不是基类的
            如果不用虚函数，基类指针指向子类的时候，只能调到基类自己实现的函数，而不能调用子类的实现
            使用一个虚函数表,该虚函数表变成可以覆盖的，那么对派生类来说，他的函数实现就是派生类的函数
            EXTEND: 静态联编和动态联编（binding)
                是什么？有什么不同？
                目前看来就是编译器确定调用哪个函数的过程，或者进行检测，静态联编指的是在编译阶段就确定了函数，而动态联编就是在运行时才确定调用哪一个函数
            EXTEND: 运行时类型检查(RTTI)
                是什么？为什么要用？包含哪些？
                使用基类的指针或者引用来检查实际的派生类型,必须在有虚函数表的情况下做才有意义
                这是多态的保证，这样才能实现多态
                typeid: 获取到当前变量的派生类型 返回的是一个type_info
                dynamic_cast:安全的由基类指针向派生类指针转换，如果失败，则为nullptr,能转换必定是基类有虚函数
                EXTEND: C++对象的内存布局
                    是什么？为什么？怎么做到的？
                    一个对象的内存分布，包含成员变量，虚函数表
                    因为要支持继承和多态的性质，那么必定在当前的对象中存储基类的成员变量，又由于需要支持多态的虚函数，那么需要一个虚函数表来支持，又由于虚继承的存在，必然设计公共基类的管理，以及如何实现多态的.
                    实现：
                        虚函数表存储的是基类的虚函数，同时若有多个父类，每个有虚函数的都会单独一个虚函数表
                        而重写虚函数之后，就会更新所有虚函数表对应虚函数里面的指向位置到最新的。
                        虚继承的，会把公共的虚基类单独拿出来见一个虚函数表
                        这样也支持了基类指针指向派生类的对象，但是这里的问题在于没有虚函数的类作为基类的时候是怎么处理的？
                            前面RTTI已经解释了对于无虚函数的基类来说，这都是没意义的，typeid返回基类类型，dynamic_cast编译就会出错
                    参考:
                        https://blog.csdn.net/ljianhui/article/details/46408645
                        book: 深入探索C++对象模型
                EXTEND: 析构函数为虚函数？编译器是怎么处理构造和析构函数的？
                    将析构函数作为虚函数的目的是为了保证当派生类被基类指针或者引用所指时能释放派生类中的资源，即调用派生类的析构函数。
                    构造函数的顺序：
                        基类构造函数，派生类本身的构造函数
                    析构顺序：
                        派生类本身的析构函数，基类的析构函数
    class、struct和Union的区别
        目的？大小？区别
        class的目的是拿来作为面对对象的，主要是包括封装继承多态的，struct呢在C里面可以认为是一个复杂数据集合，那么在c++这里又扩展了一下用上了大部分的class的功能，而union则是一个省空间的结构，表示里面只有多个元素中的某一个
        一个对象的大小在前面的c++对象的内存布局里面其实已经知道了，要注意的点就是在内存里面可能会有内存对齐的现象，其次是struct和class完全相同，Union的大小就是包含元素的最大空间的大小(因为union就是一个固定内存大小，里面包含什么元素就用什么方式去解析就可以了)
        struct和class的主要区别就在于默认的访问权限控制，struct的默认成员变量和继承都是public的，但是在class里面则默认的都是private的。然后就是class可以作为模板类，但是strcut不行。
    模板类和模板函数
        模板函数: 是什么？怎么实现？
        用泛型来定义函数，然后用具体类型进行替换，这个过程不是在底层实现的，而是在编译器层面去帮我们补充对应类型的实现
        包含隐式实例化，显示实例化，显示具体化。
            隐式实例化：直接调用，让编译器去推断，直接调用 func(a,b)
            显示实例化：指定了泛型具体是什么类型， template func<int>(int a, int b)
            显示具体化：表示针对这个具体类型用单独的实现， template<> func<int>(int a, int b)
        EXTEND: 编译器选择函数的策略
            有各种重载，模板的同名函数，那么怎么选择哪一个函数作为要运行的函数呢？
            最佳匹配  > 完全匹配 > 各种隐式转换后匹配
        EXTEND: decltype, auto实现原理
            decltype: 是什么？怎么用？怎么实现？
            对于泛型函数的操作之后，可能无法确定操作之后的值是什么类型， 如确定 x+y的类型，其实不知道
            那么定义一个 decltype(x+y) a = x+y，那么在这里编译器就根据这个表达确定属于什么类型
            分为四种，且依次判断，一个不满足才进入下一个
                1、内部为标志符,无括号包含，则为expression类型，包括const,&,*等
                2、内部为函数调用，那么就与返回类型相同
                3、double x = 1.0;decltype((x))则为double&的类型
                4、前面条件都不满足，则与expression类型相同
        EXTEND: 模板类型推断
            给定模板函数，然后直接传递参数，让编译器帮我们推导出T的类型出来，然后函数内就可以声明这个类型了，甚至可以作为返回值
            template<typename T>void f(ParamType param);
            我们首先区别T和ParamType,这两者是不同的。我们的目的是推导出T的类型，paramtype只是拿来作为我们的参考而已
                三种情况：
                    1、ParamType是引用或者指针类型：
                        parm是引用，ParamType也是引用，那么T肯定是一个忽略了引用状态的类型。
                        这也说明T的决定室友ParamType和param来共同决定的
                        如：
                            template<typename T> void f(T& a);
                            int & c = 1;
                            f(c);
                        那么这里的T的类型肯定是int,而不是int&
                            但是：
                            const int & c = 1;
                            f(c);
                        这个时候我们看到的T的类型应该是const int
                    2、对于按值传递：
                        template<typename T> void f(T param);
                        这里的问题就是非引用，那么要忽略掉const和volatile,因为这里的参数只是一个拷贝值
                        如：
                            const int& c = 1;
                            f(c);
                        这个时候的T其实是int, paramType为T，也是int
                    3、对于用右值引用的方式传递值：
                        template<typename T> void f(T&& param);
                        这个时候的就是得按照传入值得类型来确定了：
                        如：
                            int x = 27;
                            f(x);
                        那么这个时候我们的认知就是T为int&,因为为了保持param的左值性质
                            而：
                            f(27);
                        这个时候我们的认为T 为int,这也是为了保持param的右值性往下传递了，这也是一种完美转发？
                特殊情况就是数组和函数，这俩作为param传递进去的时候T的类型
                    如果是作为按值传递的话，参数模板会推断为一个指针，因为数组是可以退化为指针的
                    按引用传递，那么会推断为一个数组类型，并且是固定数组长度的数组类型
                    同理，对于函数同样的，如果按照值传递，那么传递的是函数指针，否则就是一个函数引用
            auto:
                对于auto来说，完全就可以认为是模板类型推断里面的T，所以前面的推导类型和模板函数完全一致
                但是c++11引入了一种新的特性，统一初始化，就是用{}来初始化各种情况
                    这个时候变量类型会被初始化为std::initializer_list<T>的类型，即使用{}来初始化的时候都会将大括号里面的内容转为initializer_list类型，然后再赋值或者去调用对应的支持它作为参数的构造函数(自定义的)
            decltype:
                本质上的目的是在重复一次表达式或者变量名的确切类型而已
                注意区别的是 int x = 0; decltype x 和decltype (x) 的区别
    内存管理

    traits:
        首先是对于迭代器的理解，由于迭代器的++等操作会相对的暴露太多本身容器内部的实现细节，那么把对迭代器的实现交给容器来做反而更好
        但是当我们只有一个迭代器的时候，我们是无法知道迭代器所指的内容是什么类型的，如std::vector<int> 的迭代器的解引用所指的其实是一个int，但是当换了一个std::vector<char>时，我们不知道，那么需要有一种机制来帮助我们获取到内部的类型，这就是traits.
        在对trait的使用之前，我们先来看普通条件下我们如何获取一个指针或者引用的类型
            那么用的是模板函数的函数推导，一个模板参数为I, 一个为T，传入参数的类型为item，*item，那么在此时的函数中，T就是参数类型了
            但是这只是在内部的函数中可以对参数进行推导，那么如果需要这个类型用到返回值和外部怎么办？（这里是探究的一个迭代器解引用后的类型）
                我们再回到一个容器上来说，是不是定义或者初始化的时候就能知道类型为T， 那么在类的内部做一个typedef T value_type, 那么其余的函数就可以直接用 typename I::value_type作为返回值了，这样也是一种获取到类型的方式
                刚才我们都是假设这是一个类，我们才在类的内部声明，但是若只是一个传入的只是一个指针类型怎么办？
                    萃取机的声明上去支持
        现在我们需要一个特定的模板函数，不论给到任何迭代器，我们都能直接获取到value_type(包括class类型的和指针类型的迭代器)
            template <class I> struct iterator_traits{
                typedef typename I::iterator_category iterator_category;
                typedef typename I::value_type value_type;
                typedef typename I::difference_type difference_type;
                typedef typename I::pointer pointer;
                typedef typename I::reference reference;
            }
            这个时候对于任意的一个迭代器(class类型)来说，只要它包含了前面五个类型定义，就可以用iterator_traits<Iterator>的方式获取到这几个类型
            但是这个并不支持指针型迭代器，对于指针类型，则用不同参数的模板函数，这也解释了前面的问题
            template <class I> struct iterator_traits<T*>{
                typedef typename T value_type;
            }
        那么在上述情况下，对于每一个容器内部包含的迭代器，迭代器要求包含着五个类型名称，然后就可以使用一个通用的方法来用这些了。也不用考虑迭代器是指针型的还是class型的，都用迭代器包装一层就可以

    include <>,""
        顺序？区别
        <>只是编译器自己里面的一些库函数的位置
        “”当前位置，自定义的包等的位置 

中间出现的问题:
    头文件，对应的c++实现文件是如何对应的？按照名称？
